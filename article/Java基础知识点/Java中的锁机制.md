## Java中的锁机制

#### 说锁之前先简述下并行、串行、并发、同步、异步

#### 1、并发

&nbsp;&nbsp;并发编程又叫多线程编程，并发的实质是一个物理上的CPU在若干程序之间多路复用，有限的资源多用户共享提高效率。一个CPU不可能真正同时运行多个线程，只能把CPU的时间分为多个时间段，再将各个时间段分给多个线程执行，同一时间只有一个当前线程，其它线程处于挂起状态，这种方式称为并发。

#### 2、并行

&nbsp;&nbsp;两个或者两个以上的事件或者活动在同一时刻发生。多道程序的环境下，允许程序同一时刻在不同CPU同时执行。当系统有一个以上的CPU的时候，则线程的操作有可能非并发，线程在不同的CPU执行，互不抢占CPU的资源，可以同时执行。

#### 3、并发与并行的区别

- - 并发：并发是指两个或多个事件在同一个时间间隔发生，侧重于同一实体上。
  - 并行：并行是指两个或多个事件在同一时刻发生，侧重于在不同实体上。

#### 4、串行和并行

串行是指多个任务的时候，各个任务按照顺序执行，，完成一个任务之后才能完成下一个任务；并行是多个任务可以同时进行（异步是多个任务并行的前提条件，也就是说并行的线程一定是异步执行的）。

#### 5、同步和异步的区别和联系

- - 同步和异步是指能否开启新的线程。同步不能开启新的线程，异步是可以的；
  - 异步和同步是相对的。同步是顺序执行的，执行完一个才能继续执行下一个，需要等待，协调执行；异步是彼此独立，在等待某事件的过程中，继续做自己的事情，不需要等待上一个事件完成后再继续工作；
  - 同步在多任务情况下，一个任务A执行结束，才可以执行另一个任务B，只存在一个线程；
  - 异步则是多个线程，一个任务A正在执行，同时可以执行任务B，任务B不用等待任务A结束才执行。

## 乐观锁与悲观锁

#### 悲观锁

悲观锁对应生活中悲观的人，悲观的人总是想着事情往坏的方向发展。

&nbsp;&nbsp;例如：假设厕所只有一个坑位了，悲观锁上厕所会第一时间把门反锁上，这样其他人就只能在门外等待，这种状态就是【阻塞】。

&nbsp;&nbsp;用代码来说，就是一个共享数据加上了悲观锁，那线程每次想操作这个数据前都会假设其它线程也会操作这个数据，所以每次操作时都会上锁，这样其它线程想操作这个数据拿不到锁就只能阻塞了。

![img](https://cdn.nlark.com/yuque/0/2022/png/32486163/1667140206442-a4554031-0171-410d-ba02-e7842a1bcf9c.png)

在Java语言中，synchronized 和 ReentranLock 等就是典型的悲观锁。

#### synchronized 与 ReentranLock

&nbsp;&nbsp;synchronized属于独占式悲观锁，是通过JVM隐式实现的，synchronized只允许同一时刻只有一个线程操作资源。

&nbsp;&nbsp;在Java中每个对象都隐式包含一个monitor（监视器）对象，加锁的过程其实就是竞争monitor的过程，当线程进入字节码monitorenter指令之后，线程将只有monitor对象，执行monitorexit时释放monitor对象，当其它线程没有拿到monitor对象时，则需要阻塞等待获取该对象。

&nbsp;&nbsp;ReentranLock是Lock的默认实现方式之一，它是基于AQS（Abstract Queued Synchronized，队列同步器）实现的，它默认是通过非公平锁实现的，在它的内部有一个state的状态字段用于表示锁是否被占用，如果是0则表示锁未被占用，此时线程就可以把state改为1，并成功获得锁，而其它未获得锁的线程只能去排队等待获取锁资源。

&nbsp;&nbsp;ReentrantLock中的 lock() 是通过 sync.lock() 实现的，但Sync类中的 lock() 是一个抽象方法，需要子类 NonfairSync 或 FairSync 去实现，NonfairSync 中的 lock() 源码如下：

```plain
final void lock() {
    if (compareAndSetState(0, 1))
        // 将当前线程设置为此锁的持有者
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
```

FairSync 中的 lock() 源码如下：

```plain
final void lock() {
    acquire(1);
}
```

![img](https://cdn.nlark.com/yuque/0/2022/png/32486163/1667267527618-637ebce6-a26a-4e07-b78a-083c8a2264f5.png)

可以看出非公平锁比公平锁只是多了一行compareAndSetState方法，该方法是尝试将state值由0置换为1，如果设置成功的话，则说明当前方法没有其他线程持有该锁，不用再去排队了，可直接占用该锁，否则，则需要通过acquire方法去排队。

**区别：**

- - synchronized是JVM隐式实现的，而ReenntrantLock是Java语言提供的API；
  - ReentrantLock可设置为公平锁，而synchronized不行；
  - ReentrantLock只能修饰代码块，而synchronized可以修饰方法、修饰代码块等；
  - ReentrantLock需要手动加锁和释放锁，如果忘记释放锁，则会造成资源被永久占用，而synchronized无需手动释放锁；
  - ReentrantLock可以知道是否成功获得了锁，而synchronized不行。

#### 乐观锁

&nbsp;&nbsp;乐观锁，对应生活中乐观的人，乐观的人总是讲事情往好的方向想。

&nbsp;&nbsp;例子：假如厕所只有一个坑位了，乐观锁认为：这个时间段或者这个地方，不会有人来上厕所，就不用每次浪费时间关门了。

&nbsp;&nbsp;用代码来说，乐观锁操作数据时不会上锁，在更新的时候会判断一下在此期间是否有其他线程去更新这个数据。

![img](https://cdn.nlark.com/yuque/0/2022/png/32486163/1667140464357-a024d044-18be-4d2c-a368-e7817e6f5f0d.png)

#### 两种锁的使用场景

&nbsp;&nbsp;乐观锁可以使用版本号机制和CAS算法实现，在Java语言中java.util.concurrent.atomic包下的原子类就是使用CAS乐观锁实现的。

&nbsp;&nbsp;乐观锁适用于写比较少（冲突比较小）的场景，因为不用上锁、释放锁，省去了锁的开锁，从而提升了吞吐量。

&nbsp;&nbsp;如果是写多读少的场景，即冲突比较严重，线程间竞争激励，使用乐观锁就是导致线程不断进行重试，这样可能还能降级了性能，这种场景下使用悲观锁就比较合适。

#### 关于CAS

&nbsp;&nbsp;Java中的乐观锁大部分都是通过CAS（Compare And Swap，比较并交换）操作实现的，CAS是一个多线程同步的原子指令，CAS操作包含三个重要的信息，即内存位置、预期原值和新值。如果内存位置的值和预期的原值相等的话，那么就可以把该位置的值更新为新值，否则不做任何更改。

&nbsp;&nbsp;CAS可能会造成ABA问题，ABA问题指的是，线程拿到了最初的预期原值A，然而要再进行CAS的时候，被其它线程抢占了执行权，把此值从A变成了B，然后其它线程又把此值从B变成了A，然而此时的A值并非原来的A值了，但最初的线程并不知道这个情况，在它进行CAS的时候，只对比了预期原值为A就进行了修改，这就造成了ABA问题。

&nbsp;&nbsp;ABA的常见处理方式是添加版本号或者时间戳，每次修改之后更新版本号，每次修改之前校验版本号是否被修改过，修改过则需要重新获取值再修改，这样就解决了ABA问题。

&nbsp;&nbsp;JDK在1.5时提供了 AtomicStampedReference 类也可以解决ABA问题，此类维护了一个“版本号”Stamp，每次在比较时不止比较当前值还比较版本号，这样就解决了ABA问题。

## 独占锁和共享锁

只能被单线程持有的锁叫独占锁，可以被多线程持有的锁叫共享锁。

#### 独占锁

&nbsp;&nbsp;独占锁是指锁一次只能被一个线程所持有。如果一个线程对数据加上互斥锁后，那么其它线程不能再对该数据加任何类型的锁，获得独占锁的线程技能读数据又能修改数据。

![img](https://cdn.nlark.com/yuque/0/2022/png/32486163/1667282949143-bd5edfbb-7529-4b79-95f9-3f3c19010ca9.png)

比如synchronized就是独占锁。独占锁可以理解为悲观锁。

#### 共享锁

&nbsp;&nbsp;共享锁是指可被多个线程所持有。如果一个线程对数据加上共享锁后，那么其它线程只能对数据再加共享锁，不能加独占锁。获得共享锁的线程只能读数据，不能修改数据。

![img](https://cdn.nlark.com/yuque/0/2022/png/32486163/1667283098190-a4580143-ae88-42e1-aa3c-fe7c6d723fc9.png)

在JDK中 ReetrantReadWriteLock 就是一种共享锁。共享锁可以理解为乐观锁，它放宽了加锁条件，允许多线程同时访问该资源。

## 互斥锁和读写锁

#### 互斥锁

互斥锁是独占锁的一种常规实现，是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排他性。

![img](https://cdn.nlark.com/yuque/0/2022/png/32486163/1667283460712-302c3455-2860-4c8e-8440-05162e82a6cb.png)

一次只能有一个线程拥有互斥锁，其它线程只能等待。

#### 读写锁

&nbsp;&nbsp;读写锁是共享锁的一种具体实现，读写锁管理一组锁，一个是只读的锁，一个是写锁。

&nbsp;&nbsp;读锁可以在没有写锁的时候被多个线程同时拥有，而写锁是独占的。写锁的优先级高于读锁，一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。

&nbsp;&nbsp;读写锁相比于互斥锁并发程度更高，每次只有一个写线程，但是可以同时有多个线程并发读。

![img](https://cdn.nlark.com/yuque/0/2022/png/32486163/1667283805212-9af359d0-51ec-4a2e-9691-d0e97fa96d79.png)

在JDK中定义了一个读写锁的接口：ReadWriteLock

```plain
public interface ReadWriteLock {
    /**
     * 获取读锁
     */
    Lock readLock();
 
    /**
     * 获取写锁
     */
    Lock writeLock();
}
```

ReentrantReadWriteLock 实现了 ReadWriteLock 接口。

## 公平锁和非公平锁

&nbsp;&nbsp;公平锁的含义是线程需要按照请求的顺序来获得锁；而非公平锁则允许有“插队”的情况存在，所谓的“插队”指的是：线程在发送请求的同时该锁的状态恰好变成了可用，那么此线程可以跳过队列中所有排队的线程直接拥有该锁。

&nbsp;&nbsp;公平锁由于有挂起和恢复所以存在一定开销，因此性能不如非公平锁，所以  ReentrantLock 和 synchronized 默认都是非公平锁的实现方法。

![img](https://cdn.nlark.com/yuque/0/2022/png/32486163/1667284390638-0ef9a7d4-0f0d-439b-88b7-48f3f974979a.png)

![img](https://cdn.nlark.com/yuque/0/2022/png/32486163/1667284396919-56ef22da-ca1e-4767-9d3f-29a5e40feb5c.png)

```plain
//创建一个可重入锁，true 表示公平锁，false 表示非公平锁；
//默认为false，非公平锁。
Lock lock = new ReetrantLock(false);
```

## 可重入锁

&nbsp;&nbsp;可重入锁又称为递归锁，是指同一个线程在外层方法获取了锁，在进入内层方法也会自动获取锁。

&nbsp;&nbsp;在Java中，ReentrantLock 和 synchronized 都是可重入锁。

&nbsp;&nbsp;实现原理：可重入锁是在锁内部存储了一个线程标识，用于判断当前的线程属于哪个线程，并且锁的内部维护了一个计数器，当锁空闲时此计数器为0，当被线程占用和重入时分别加1，当锁被释放时计数器减1，直到减到0时表示此锁为空闲状态。

&nbsp;&nbsp;可重入锁可以一定程度上避免线程死锁，以synchronized为例：

```plain
public synchronized void methodA() throws Exception{
	methodB();
}

public synchronized void methodB() throws Exception{

}
```

&nbsp;&nbsp;上面的代码中，methodA调用methodB，如果一个线程调用methodA已经获取了锁再去调用methodB就不需要再次获取锁了，这就是可重入锁的特性；如果不是可重入锁的话，methodB可能不会被当前线程执行，造成死锁。

## 自旋锁

&nbsp;&nbsp;自旋锁是指线程在没有获得锁时不是被直接挂起，而是执行一个忙虚幻，这个忙循环就是所谓的自旋。

![img](https://cdn.nlark.com/yuque/0/2022/png/32486163/1667286544216-c4ff2feb-d6ef-41bc-80a2-893daf6148d1.png)

&nbsp;&nbsp;自旋锁的目的是为了减少线程被挂起的几率，因为线程的挂起和唤醒也是都是需要消耗资源的操作。但是如果锁被另一个线程占用的时间较长，即使自旋了之后当前线程还是会被挂起，忙循环就会变成浪费系统资源的操作，反而降低了整体性能，因此自旋锁不适用于锁占用时间长的并发情况。

#### 自适应自旋锁

&nbsp;&nbsp;在JDK1.6中引入了自适应自旋锁，自旋时间不在固定，由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。如果虚拟机认为这次自旋也很有可能再次成功那就会自旋较多的时间，如果自旋很少成功，那以后可能就会直接省略掉自旋过程，避免浪费处理器资源。

## 锁升级

&nbsp;&nbsp;JDK1.6为了提升性能减少获得锁和释放锁所带来的消耗，引入了四种锁的状态：无锁、偏向锁、轻量级锁和重量级锁，它会随着多线程的竞争状况逐渐升级，但不能降级。也成为膨胀锁。

#### 无锁

&nbsp;&nbsp;不存在竞争关系

#### 偏向锁

&nbsp;&nbsp;偏向锁是指在无竞争的情况下设置的一种锁状态。偏向锁的意思是它会偏向于第一个获取它的线程，当锁对象第一次被获取到之后，会在此对象头中（Mark Word）设置标示为“01”，表示偏向锁的模式，并且在对象头中记录此线程的 ID，这种情况下，如果是持有偏向锁的线程每次在进入的话，不再进行任何同步操作，如 Locking、Unlocking 等，直到另一个线程尝试获取此锁的时候，偏向锁模式才会结束，偏向锁可以提高带有同步但无竞争的程序性能。但如果在多数锁总会被不同的线程访问时，偏向锁模式就比较多余了，此时可以通过 UseBiasedLocking 来禁用偏向锁以提高性能。

#### 轻量级锁

&nbsp;&nbsp;当锁升级为轻量级锁时，线程会在自己的虚拟机栈中开辟一块为Lock Record的空间，lock record 中会对存储对象头中Mark Word 的副本以及owner指针，线程会通过CAS尝试获得解锁，一旦获得解锁，就会将Mark Word 复制到lock record 中，并将owner指针指向该对象，另一方面，该对象的Mark Word 中的指针会指向获得锁的线程的lock record，就完成了获得获取与绑定。其它的线程想要获得锁，会自选等待。

#### 重量级锁

&nbsp;&nbsp;如果线程长时间的自旋或等待的线程特别多，就会进行下一步的锁升级，也就是升级为重量级锁，通过操作系统来操作线程。JDK1.6规定的是，线程自旋10 次会升级为重量级锁，或等待线程的数量超过CPU合数的1/2，升级为重量级锁，这两个参数乐意通过JVM调优来设置，但目前JVM会自适应，有JVM来决定什么时候升级为重量级锁。

升级为重量级锁其实就是互斥锁了，一个线程拿到锁，其余线程都会处于阻塞等待状态。

## 图解

![img](https://cdn.nlark.com/yuque/0/2022/png/32486163/1667290295820-8bb80872-7389-4ecd-8e23-8a7e35825398.png)